package diva;

require "platform:/lookup/diva.model/model/DiVA.ecore"
//require "platform:/resource/diva.model/model/DiVA.ecore" 
require "DiVA2Alloy.kmt"

using kermeta::standard
using kermeta::utils

class StateMachine {
	attribute states : Hashtable<String, State>
	
	operation create() : StateMachine is do
		states := Hashtable<String, State>.new
		result := self
	end
	
	operation getOrCreateState(cxt : Context, m : VariabilityModel) : State is do
		var cfg : Configuration init cxt.bestConfiguration
		result := states.getValue(cfg.id(m))
		if result == void then
			result := State.new
			result.name := cfg.id(m)
			states.put(result.name, result)
			cfg.variant.each{ cv | result.variant.add(cv.variant) }
		end
		result.context.add(cxt)
	end
	
	operation addTransition(src : Context, tgt : Context, m : VariabilityModel) : Transition is do
		var s : State init getOrCreateState(src, m)
		var t : State init getOrCreateState(tgt, m)
		result := Transition.new
		result.diff.addAll(tgt.changes_from(src))
		result.source := s
		result.target := t
		result.name := ""
		result.diff.each{ vv | 
			if result.name.size > 0 then result.name := result.name + " and " end
			result.name := result.name + vv.toString
		}
	end
	
	operation exportDot() : String is do
		result := "digraph adaptation_sm {\n"
		states.values.each{ s |
			result.append(s.name + "[ label = \""+s.name+"("+s.context.size.toString+")\" ];\n")
		}
		states.values.each{ s |
			s.outgoing.each{ t |
				if t.source != t.target then
					result.append(t.source.name + " -> " + t.target.name + "[ label = \""+t.name+"\" ];\n")
				end
			}
		}
		
		result.append("}\n")
	end
	
	operation exportDotForVariable(v : Variable) : String is do
	
		result := "digraph adaptation_sm {\n"
		states.values.each{ s |
			result.append(s.name + "[ label = \""+s.name+"("+s.context.size.toString+")\" ];\n")
		
		}
		states.values.each{ s |
			s.outgoing.each{ t |
				if t.source != t.target and t.diff.one.variable == v then
					result.append(t.source.name + " -> " + t.target.name + "[ label = \""+t.name+"\" ];\n")
				end
			}
		}
	
		result.append("}\n")
		
	end
	
}

class State inherits NamedElement {
	reference variant : Variant[*]
	reference context : Context[*]
	
	attribute outgoing : Transition[*]#source
	reference incoming : Transition[*]#target
	
	operation getVariableColor(v : Variable) : String is do
		var bv : BooleanVariable
		
		bv ?= v
		
		result := void
		//TODO: Finish this !!
	end
	
}

class Transition inherits NamedElement {
	reference diff : VariableValue[0..*]
	reference source : State#outgoing
	reference target : State#incoming
}


aspect class VariabilityModel {

	
	operation exportSimulationStateMachine() is do
		if simulation != void then
			var s : Scenario init simulation.scenario.detect{ s | s.name == "EXHAUSTIVE" }
			if s != void then
			
				var sm : StateMachine init StateMachine.new.create
				
				// create all states
				s.context.each{ c |
					sm.getOrCreateState(c, self)
				}
			
				var diff : Set<VariableValue>
				var trans : Transition
				var bvv : BoolVariableValue
				
				sm.states.values.each{ s |
					s.context.each{ sc |
						sm.states.values.each{ ts |
							ts.context.each{ tsc |
								diff := tsc.changes_from(sc)
								if diff.size == 1 then
									if not s.outgoing.exists{ t | t.diff.one == diff.one } then
										bvv ?= diff.one
										if bvv != void then 
											if bvv.bool then
												trans := Transition.new
												trans.diff.addAll(diff)
												trans.source := s
												trans.target := ts
												trans.name := diff.one.toString
											end
										else
											trans := Transition.new
											trans.diff.addAll(diff)
											trans.source := s
											trans.target := ts
											trans.name := diff.one.toString
										end
									end
								end
							}
						}
					}
				}
				
				stdio.writeln(sm.exportDot)
				
				context.each{ v | 
				stdio.writeln("\n\n************************************")
				stdio.writeln("FOR VARIABLE : " + v.name)
				stdio.writeln("************************************")
				stdio.writeln(sm.exportDotForVariable(v))
				
				}
				
			end
		
		end
	end
	
	operation exportSimulationStateMachine2() is do
		if simulation != void then
			var s : Scenario init simulation.scenario.detect{ s | s.name == "EXHAUSTIVE" }
			if s != void then
			
				var sm : StateMachine init StateMachine.new.create
				var next : Context
			
				var it : Iterator<Context> init s.context.iterator
				from var current : Context init it.next
				until current == void or not it.hasNext
				loop
					next := it.next
					sm.addTransition(current, next, self)
					current := next
				end
				
				stdio.writeln(sm.exportDot)
				
			end
		
		end
	end
	
	
}


aspect class SimulationModel {

	operation computeVerdicts() is do
		scenario.each{ s | s.computeVerdicts }
	end

	
	operation allPriorities() : Hashtable<Property, Set<Integer>> is do
		result := Hashtable<Property, Set<Integer>>.new
		var s : Set<Integer>
		model.rule.each{ r |
			r.asType(PriorityRule).priority.select{ p | p.priority != 0 }.each{ p |
				s := result.getValue(p.~property)
				if s == void then 
					s := Set<Integer>.new 
					result.put(p.~property, s)
				end
				s.add(p.priority)
			}
		}
	end
	
	operation uncoveredPriorities(covered : Hashtable<Property, Set<Integer>>, all : Hashtable<Property, Set<Integer>>) : Hashtable<Property, Set<Integer>> is do
		result := Hashtable<Property, Set<Integer>>.new
		var s : Set<Integer>
		var c : Set<Integer>
		var r : Set<Integer>
		all.keys.each{ prop |
			s := all.getValue(prop)
			r := Set<Integer>.new
			if covered.containsKey(prop) then
				c := covered.getValue(prop)
				s.each{ v |	if not c.contains(v) then r.add(v) end }
			else
				r.addAll(s)
			end
			if not r.empty then result.put(prop, r) end
		}
	end
	
	
}


aspect class Scenario {
	
	operation computeVerdicts() is do
		context.each{ c | c.computeVerdicts }
	end

}


aspect class Invariant
{
	operation check(ctx : Context, cfg : Configuration) : Boolean is do
		result := expression.eval(ctx, cfg)
	end
}

aspect abstract class Term
{
	operation computeVariantEffect(v : Hashtable<Variant, Boolean>, b : Boolean) : Void is abstract
}
aspect class AndTerm
{
	
	method computeVariantEffect(v : Hashtable<Variant, Boolean>, b : Boolean) : Void is do
		if b then term.each{t | t.computeVariantEffect(v,b)}
		else raise "non determinism in effect of basic rule (AND)"
		end
	end
	
}
aspect class OrTerm
{
	method computeVariantEffect(v : Hashtable<Variant, Boolean>, b : Boolean) : Void is do
		if not b then term.each{t | t.computeVariantEffect(v,b)}
		else raise "non determinism in effect of basic rule (OR)"
		end
	end
	
}
aspect class NotTerm
{
	method computeVariantEffect(v : Hashtable<Variant, Boolean>, b : Boolean) : Void is do
		term.computeVariantEffect(v, not b)
	end
	
}


aspect class VariantTerm
{
	method equals(other : Object) : Boolean is do
		if other.getMetaClass == self.getMetaClass then
			result := variant == other.asType(VariantTerm).variant
		else
			result := false
		end
	end
	
	method computeVariantEffect(v : Hashtable<Variant, Boolean>, b : Boolean) : Void is do
		v.put(variant, b)
	end
	
	method toString() : String is do
		result := variant.name
	end
	
}
aspect abstract class VariableTerm
{
	
	method computeVariantEffect(v : Hashtable<Variant, Boolean>, b : Boolean) : Void is do
		// nothing to do
	end
}
aspect class EnumTerm
{
	method equals(other : Object) : Boolean is do
		if other.getMetaClass == self.getMetaClass then
			result := variable == other.asType(EnumTerm).variable and
					  ~value == other.asType(EnumTerm).~value
		else
			result := false
		end
	end

}
aspect class BooleanTerm
{
	method equals(other : Object) : Boolean is do
		if other.getMetaClass == self.getMetaClass then
			result := variable == other.asType(BooleanTerm).variable
		else
			result := false
		end
	end	
}

	
aspect abstract class VariableValue {
	operation hasSameValue(other : VariableValue) : Boolean is abstract
	operation clone() : VariableValue is abstract
}

aspect class BoolVariableValue {

	method equals(other : Object) : Boolean is do
		result := false
		var o : BoolVariableValue 
		o ?= other
		if o != void then
			result := self.variable == o.variable and self.bool == o.bool
		end
	end

	method clone() : VariableValue is do
		var res : BoolVariableValue init BoolVariableValue.new
		res.variable := self.variable
		res.bool := self.bool
		result := res
	end

	method hasSameValue(other : VariableValue) : Boolean is do
		var o : BoolVariableValue
		o ?= other
		if o != void then
			result := bool == o.bool
		else
			result := false
		end
	end
	method toString() : String is do
		result := variable.id
		if not bool then
			result := "not " + result
		end
	end
}

aspect class EnumVariableValue {

	method equals(other : Object) : Boolean is do
		result := false
		var o : EnumVariableValue 
		o ?= other
		if o != void then
			result := self.variable == o.variable and self.literal == o.literal
		end
	end

	method clone() : VariableValue is do
		var res : EnumVariableValue init EnumVariableValue.new
		res.variable := self.variable
		res.literal := self.literal
		result := res
	end
	
	method hasSameValue(other : VariableValue) : Boolean is do
		var o : EnumVariableValue
		o ?= other
		if o != void then
			result := literal == o.literal
		else
			result := false
		end
	end
	
}

aspect class Context {

	operation changes_from(other : Context) : Set<VariableValue> is do
		var ovv : VariableValue
		result := Set<VariableValue>.new
		self.variable.each { vv |
			ovv := other.variable.detect{ ovvv | ovvv.variable == vv.variable }
			if not ovv.hasSameValue(vv) then
				result.add(vv)
			end
		}
	end

	operation computeVerdicts() is do
		configuration.each{ c | c.computeVerdicts(oracle) }
		var cfg : Configuration init bestConfiguration
		if cfg == void then
			verdict := Verdict.fail
		else
			verdict := cfg.verdict
		end
	end
	
}
	
aspect class Configuration {

	operation id(m : VariabilityModel) : String is do
			result := "CFG"
			m.dimension.each{d | d.variant.each{v |
				if variant.exists{ cv | cv.variant == v} then
					result := result + "_" + v.id
				end
			}}
	end
		
	operation computeVerdicts(oracle : VariantExpression) is do
		if oracle != void then
			if oracle.eval(void, self) then
				verdict := Verdict.pass
			else
				verdict := Verdict.fail
			end
		end
	end
}